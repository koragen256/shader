<html>
	<head>
        <style>
            /* キャンバスを元のサイズに拡大表示 */
            canvas {
                width: 100%;
                height: 100%;
            }
        </style>
		<!-- fragment shader -->
		<script id="fs" type="x-shader/x-fragment">
            precision mediump float;
            uniform float time;
            uniform vec2 mouse;
            uniform vec2 resolution;
            
            const float e = exp(1.);
            const vec3 cPos = vec3(0,0,10);
            // rotate
            vec3 rotate(vec3 p, float angle, vec3 axis){
                vec3 a = normalize(axis);
                float s = sin(angle);
                float c = cos(angle);
                float r = 1.0 - c;
                mat3 m = mat3(
                    a.x * a.x * r + c,
                    a.y * a.x * r + a.z * s,
                    a.z * a.x * r - a.y * s,
                    a.x * a.y * r - a.z * s,
                    a.y * a.y * r + c,
                    a.z * a.y * r + a.x * s,
                    a.x * a.z * r + a.y * s,
                    a.y * a.z * r - a.x * s,
                    a.z * a.z * r + c
                );
                return m * p;
            }
            
            float softMax(float a,float b,float R){
                return (1./R)*log(exp(a*R)+exp(b*R));
            }
            
            float d_Sphere(vec3 p,float size){
                return length(p)-size;
            }
            
            float d_Box(vec3 p,float s){
                p = mod(p,20.)-10.;
                float c = length(max(abs(p)-s,-0.18))-0.2;
                return c;
            }
            
            float sdf(vec3 p){
                vec3 vp1 = vec3(cos(time)*2.,sin(time)*2.,-2.);
                vec3 vp2 = vec3(cos(time*3.)*3.,sin(time*2.)*2.,2.*cos(time));
                vec3 vp3 = vec3(-cos(time/2.)*5.,sin(time/4.)*6.,sin(time/3.)*6.);
                float s1 = d_Sphere(p,2.5);
                float s2 = d_Sphere(p+vp1,2.9);
                float s3 = d_Sphere(p+vp2,1.4);
                float s1_2 = softMax(s1,-s2,4.);
                float b1 = d_Box(p,sin(time)+2.);
                float Main = min(b1,(-softMax(-s1_2,-s3,1.)));
            
                float s4 = d_Sphere(p+vp3,1.0);
            
                Main = -max(-Main,-s4);
            
                vec3 Cvp = rotate(cPos*3., time*1.1, vec3(0,0.3,1));
                float Cs = d_Sphere(p-Cvp,20.);
                
                return max(Main,-Cs);
            }
            
            vec3 getNormal(vec3 p){
                float d = 0.001;
                return normalize(vec3(
                    sdf(vec3(p.x+d,p.y,p.z))-sdf(vec3(p.x-d,p.y,p.z)),
                    sdf(vec3(p.x,p.y+d,p.z))-sdf(vec3(p.x,p.y-d,p.z)),
                    sdf(vec3(p.x,p.y,p.z+d))-sdf(vec3(p.x,p.y,p.z-d))
                ));
            }
            
            vec3 trace(vec3 pos,vec3 ray){
            
                ray = rotate(ray, time*0.1, vec3(0,0.3,1));
                pos = rotate(pos, time*0.1, vec3(0,0.3,1));
                pos*=3.;
                float d=0.;
                vec3 color=vec3(1.0, 0.5255, 0.9765);
                for(int i=0;i<64;i++){
                    d = sdf(pos);
                    color = (getNormal(pos)+vec3(0.3,0.3,0.3));
                    pos += d*ray;
                    if(d<0.05){
                        break;
                    }
                }
            
                if(d>0.3){
                    color=vec3(0.8627, 0.9725, 1.0);
                }
            
                return color;
            }
            
            void main() {
                
                
                vec2 pos = (2.0*gl_FragCoord.xy-resolution.xy)/min(resolution.x,resolution.y);
                
                vec3 ray = normalize((vec3(pos,0)-cPos)*vec3(2,2,1));
                gl_FragColor = vec4(trace(cPos,ray),1);
            }
		</script>
		<!-- /fragment shader -->

		<!-- vertex shader -->
		<script id="vs" type="x-shader/x-vertex">
			attribute vec3 position;
			void main(void){
			    gl_Position = vec4(position, 1.0);
			}
		</script>
		<!-- /vertex shader -->

		<script src="script.js" type="text/javascript"></script>
	</head>
	<body style="margin: 0;">
		<canvas
			id="canvas"
			style="display: inline">
        </canvas>
	</body>
</html>
